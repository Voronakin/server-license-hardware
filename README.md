# server-license-hardware

Библиотека на языке Go для генерации и проверки лицензий на программное обеспечение.

## Основное назначение

**Внедрение в проекты для защиты ПО** - библиотека предназначена для интеграции в приложения для управления доступом и лицензированием.

Библиотека создает JWT токены, содержащие хэши сервера на основе его аппаратных характеристик, что предотвращает 
повторное использование лицензий на других серверах.
JWT токены подписываются с использованием асимметричного шифрования. Библиотека поддерживает ОС Windows и Linux.

## Дополнительная возможность

**Простой сервер генерации лицензий** - инструмент `cmd/license-generator` может использоваться как самостоятельное приложение для выдачи лицензий.

## Архитектура

Пакет включает 4 компонента:

1. **Генератор хэша машины** (`pkg/hosthash`) - создает JSON с характеристиками оборудования, уникальными для каждой машины
2. **Шифрование** (`pkg/crypt`) - симметричное шифрование хэша машины с использованием AES
3. **Генератор лицензий** (`pkg/license/generator.go`) - создает JWT токен на основе зашифрованного хэша, подписанный асимметричным ключом
4. **Валидатор лицензий** (`pkg/license/validator.go`) - проверяет подпись лицензии и сравнивает характеристики с текущей машиной

## Использование (внедрение в проекты)

### Интеграция в приложение

```go
import (
    "voronakin/server-license-hardware/hosthash"
    "voronakin/server-license-hardware/license"
)

// В реальном проекте эти ключи должны быть зашиты в приложение
const (
    hashKey    = "ваш_32_байтный_ключ_шифрования_хэша" // Должен быть одинаковым на сервере и клиенте
    publicKey  = `-----BEGIN PUBLIC KEY-----
ваш_публичный_rsa_ключ
-----END PUBLIC KEY-----`
)

// Генерация хэша машины
hash, err := hosthash.GenHash()

// Определение scope для конкретного приложения
allScopes := []license.Scope{
    {ID: "read", Name: "Чтение", Description: "Доступ на чтение данных"},
    {ID: "write", Name: "Запись", Description: "Доступ на запись данных"},
    {ID: "admin", Name: "Администрирование", Description: "Полный доступ к системе"},
}

// Создание генератора (для сервера лицензий)
// Использует приватный ключ, который НЕ должен попадать в клиентские приложения
generator := license.NewGenerator([]byte(privateKey), allScopes)

// Создание валидатора (для клиентских приложений)
// Использует публичный ключ, который зашивается в приложение
validator := license.NewValidator([]byte(publicKey), allScopes)

// Создание лицензии (на сервере)
licenseToken, err := generator.Create(license.CreateOptions{
    HardwareHash: license.EncryptHash(hash, hashKey), // Хэш шифруется для сокрытия параметров оборудования
    Name:         "Тестовая лицензия",
    ExpiresAt:    expTime,
    Scopes:       []string{"read", "write"},
})

// Валидация лицензии (на клиенте)
// Простая проверка валидности
isValid := validator.Validate(licenseToken, hashKey)
// Получение подробной информации о лицензии
licenseInfo := validator.ValidateDetails(licenseToken, hashKey)

// Проверка scope
if licenseInfo.CheckScope("read") {
    // Разрешить доступ на чтение
}
```

### Сценарии использования

- **Защита коммерческого ПО** - предотвращение нелегального распространения
- **Управление доступом** - гибкая система разрешений через scope
- **Ограничение по оборудованию** - привязка лицензии к конкретному серверу
- **Временные лицензии** - ограничение срока действия

## Установка

```bash
go get github.com/voronakin/server-license-hardware
```

## Примеры

### Пример интеграции
См. `cmd/example/main.go`.

### Генератор хэша сервера
Инструмент `cmd/hash-generator` для генерации зашифрованного хэша оборудования:

```bash
# Генерация зашифрованного хэша (ключ зашит в коде)
go run cmd/hash-generator/main.go
```

**Важно**: Ключ шифрования зашит в коде приложения и должен быть одинаковым на сервере генерации лицензий и во всех клиентских приложениях.

### Сервер генерации лицензий
Используйте `cmd/license-generator` как вариант реализации инструмент для выдачи лицензий:

```bash
# Интерактивный режим
go run cmd/license-generator/main.go --interactive

# Прямая генерация
go run cmd/license-generator/main.go private.pem myhashkey123 "Моя лицензия" 365 read,write,admin
```

## Реальный пример использования

1. На клиентской машине с помощью `cmd/hash-generator` генерируется зашифрованный хэш оборудования и отображается пользователю
   - **Важно**: Ключ шифрования зашит в коде приложения
2. Пользователь предоставляет этот хэш сервису генерации лицензий
3. Сервер генерации лицензий создает лицензию на основе предоставленного хэша
   - **Важно**: Сервер использует тот же ключ шифрования, что и клиентское приложение
4. Полученная лицензия сохраняется в текстовом файле на машине пользователя
5. Приложение проверяет лицензию при запуске и ограничивает функционал в соответствии со scope

## Безопасность

### Управление ключами

**При реальном использовании в конечное ПО должны быть зашиты:**
- **Ключ шифрования хэша** (AES) - для шифрования/дешифрования хэша оборудования
- **Публичный ключ** (RSA) - для проверки подписи JWT токенов

**Приватный ключ** (RSA) используется только на сервере генерации лицензий и никогда не должен попадать в клиентские приложения.

### Назначение шифрования хэша

Шифрование хэша оборудования служит для:
- **Защиты от анализа** - скрывает, какие именно параметры оборудования используются для генерации хэша
- **Усложнения подгонки** - затрудняет подбор характеристик сервера под существующую лицензию

### Криптографические методы

- **Асимметричное шифрование** - RSA подпись JWT токенов
- **Симметричное шифрование** - AES шифрование хэша оборудования
- **Привязка к оборудованию** - предотвращение передачи лицензий
- **Гибкая система scope** - управление правами доступа

## Генерация ключей

### Генерация RSA ключей для асимметричного шифрования

Для подписи JWT токенов используются пары RSA ключей. Приватный ключ используется на сервере генерации лицензий,
публичный ключ зашивается в клиентские приложения.

#### Использование OpenSSL:

```bash
# Генерация приватного ключа RSA (2048 бит)
openssl genrsa -out private.pem 2048

# Извлечение публичного ключа из приватного
openssl rsa -in private.pem -pubout -out public.pem
```

### Генерация AES ключа для шифрования хэша

Для шифрования хэша оборудования используется симметричное шифрование AES-CBC. Ключ должен быть ровно 32 байта (256 бит).

#### Генерация случайного ключа:

```bash
# Генерация случайного 32-байтного ключа в hex формате
openssl rand -hex 32
```

**Важно**: Ключ шифрования хэша должен быть одинаковым на сервере генерации лицензий и во всех клиентских приложениях.

## Лицензия

MIT License